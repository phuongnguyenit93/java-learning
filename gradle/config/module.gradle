import groovy.json.JsonOutput
import groovy.json.JsonSlurper

ext.getFolderProps = {
    List<HashMap> dirListProps = new ArrayList<>()

    List<File> folderList = fileTree(rootDir) {
        include '**/gradle.properties'
        exclude 'gradle.properties'
        exclude '**/build'

    }.files.unique()
            .collect { it.parentFile }

    folderList.eachWithIndex{ File folder, Integer index ->

        File propFile = new File(folder,"gradle.properties")
        def props = new Properties()
        propFile.withInputStream { props.load(it) }

        HashMap<String,String> propMap = new HashMap(props)

        String absolutePath = folder.absolutePath.replace(File.separator,"/")
        propMap.put("ABSOLUTE_PATH",absolutePath)

        String modulePath = (folder.absolutePath + File.separator)
                .replace(rootDir.absolutePath + File.separator, '')
                .replace(File.separator, ':').toString()
                .with {it.substring(0,it.length()-1)}
        propMap.put("MODULE_PATH",modulePath)

        String jarPath = modulePath.replace(":","/")
        propMap.put("JAR_PATH",jarPath)


        dirListProps.add(propMap)
    }

    return dirListProps
}


ext.addModule = {List<HashMap> dirListProps ->
    dirListProps.each { HashMap prop ->
        def modulePath = prop.get("MODULE_PATH")

        if (prop.IS_MICROSERVICE == 'true') {
            include ":${modulePath}"
        }
    }
}

ext.injectTask = {
    def GREEN = "\u001B[32m"
    def YELLOW = "\u001B[33m"
    def RESET = "\u001B[0m"
    def CYAN = "\u001B[36m"
    def BLUE = "\u001B[34m"

    println "${BLUE}=================================================="
    println "üîç T·∫†O RA C√ÅC FILE TASK.GRADLE ·ªû MODULE V√Ä COPY C√ÅC TASK D√ÄNH RI√äNG CHO C√ÅC MODULE V√Ä B·ªé V√ÄO ƒê√ì"
    println "${BLUE}==================================================${RESET}"

    println "${BLUE}üöÄ [INJECT-ENGINE] B·∫Øt ƒë·∫ßu qu√° tr√¨nh qu√©t v√† ph√¢n ph·ªëi Task...${RESET}"

    HashMap<String, List<String>> taskContent = new HashMap()
    HashMap<String, List<String>> moduleContent = new HashMap()

    def taskListProp = [
            [type: "module", fileName: "module.gradle", propCheck: ""],
            [type: "env", fileName: "env.gradle", propCheck: "BUILD_ENV"],
            [type: "readme", fileName: "readme.gradle", propCheck: "BUILD_README"],
            [type: "properties", fileName: "properties.gradle", propCheck: "BUILD_PROPERTIES"]
    ]

    def extractBlocks = { tagName, fileText ->
        def pattern = /(?s)\/\/ START_${tagName}\s*\n(.*?)\n\s*\/\/ END_${tagName}/
        def matcher = (fileText =~ pattern)
        return matcher.collect { it[1].trim() }
    }

    // Giai ƒëo·∫°n 1: Tr√≠ch xu·∫•t t·ª´ Template
    println "${CYAN}üìÇ B∆∞·ªõc 1: Tr√≠ch xu·∫•t d·ªØ li·ªáu t·ª´ c√°c file Template...${RESET}"
    taskListProp.each { task ->
        String fileName = task.get("fileName")
        def templateFile = file("${rootDir}/gradle/task/${fileName}")

        if (templateFile.exists()) {
            def fileText = templateFile.text
            def tasks = extractBlocks("MY_TASK", fileText)
            def modules = extractBlocks("MY_MODULE_APPLY", fileText)

            taskContent.put(task.get("type"), tasks)
            moduleContent.put(task.get("type"), modules)
            println "   + [${task.type}]: T√¨m th·∫•y ${GREEN}${tasks.size()}${RESET} tasks v√† ${GREEN}${modules.size()}${RESET} module blocks."
        } else {
            println "   + [${task.type}]: ${YELLOW}C·∫£nh b√°o: Kh√¥ng t√¨m th·∫•y file ${fileName}${RESET}"
        }
    }

    // Giai ƒëo·∫°n 2: Ph√¢n ph·ªëi xu·ªëng subprojects
    println "${CYAN}üèóÔ∏è  B∆∞·ªõc 2: Ti·∫øn h√†nh Inject file task.gradle v√†o c√°c subprojects...${RESET}"
    subprojects { project ->
        def propFile = file("${project.projectDir}/gradle.properties")
        if (!propFile.exists()) return

        def props = new Properties()
        propFile.withInputStream { props.load(it) }
        def serviceName = props.getProperty("SERVICE_NAME")
        def isInjectTask = props.getProperty("INJECT_TASK_AUTO")

        if (serviceName != null && !serviceName.isEmpty() && isInjectTask == "true") {
            String moduleContentFinal = ""
            String taskContentFinal = ""
            def injectedTypes = []

            taskListProp.each { task ->
                def propCheckKey = task.get("propCheck")
                def isPropActive = (propCheckKey == "" || props.getProperty(propCheckKey) == "true")

                if (isPropActive) {
                    def tasksToInject = taskContent[task.get("type")] ?: []
                    def moduleToInject = moduleContent[task.get("type")] ?: []

                    if (!tasksToInject.isEmpty() || !moduleToInject.isEmpty()) {
                        injectedTypes << task.get("type")

                        moduleToInject.each { String code -> moduleContentFinal += code + "\n" }

                        tasksToInject.each { String originalCode ->
                            def namePattern = /(?:tasks\.register\s*\(?\s*['"]|task\s+)(\w+)/
                            def nameMatcher = (originalCode =~ namePattern)

                            if (nameMatcher.find()) {
                                def originalTaskName = nameMatcher.group(1)
                                def newTaskName = "${originalTaskName}_${serviceName}"
                                def customizedCode = originalCode.replaceAll(/(?<!ext\.)\b${originalTaskName}\b/, newTaskName)
                                taskContentFinal += "// Injected from ${task.type}: ${originalTaskName}\n" + customizedCode + "\n\n"
                            }
                        }
                    }
                }
            }

            def targetFile = file("${project.projectDir}/task.gradle")
            if (!moduleContentFinal.isEmpty() || !taskContentFinal.isEmpty()) {
                if (!targetFile.exists()) targetFile.createNewFile()
                targetFile.text = "// AUTO GENERATED FILE - DO NOT EDIT\n\n" + moduleContentFinal + "\n" + taskContentFinal
                println "   ‚úÖ Module [${GREEN}${serviceName}${RESET}]: ƒê√£ inject th√†nh c√¥ng (${injectedTypes.join(', ')})"
            }
        } else if (serviceName != null) {
             // Log nh·ªØng module b·ªã b·ªè qua nh∆∞ng c√≥ SERVICE_NAME ƒë·ªÉ d·ªÖ ki·ªÉm so√°t
//             println "   ‚è© Module [${serviceName}]: B·ªè qua (INJECT_TASK_AUTO=false)"
        }
    }
    println "${BLUE}==================================================${RESET}"
}

ext.getModulePropByKeyValue = { String key, String value, List<HashMap> dirListProps ->
    return dirListProps.findAll { HashMap prop ->
        if (value == null) {
            if (prop.containsKey(key)) return true
        } else {
            if (prop[key] != value) return false
        }

        return true
    }
}

ext.getAllModuleProperties = { Set currentProjectKeys ->
    def GREEN = "\u001B[32m"
    def YELLOW = "\u001B[33m"
    def RESET = "\u001B[0m"
    def CYAN = "\u001B[36m"
    def PURPLE = "\u001B[35m"

    println "${PURPLE}=================================================="
    println "${PURPLE}üìä [PROPERTY-TRACKER] L·∫•y danh s√°ch Config ·ªü gradle.properties c·ªßa c√°c module con ${RESET}"
    println "${PURPLE}==================================================${RESET}"

    def jsonFile = file("${rootDir}/module-properties.json")
    def masterData = [:]

    if (jsonFile.exists()) {
        try {
            masterData = new JsonSlurper().parseText(jsonFile.getText("UTF-8"))
        } catch (Exception e) {
            println "   ‚ö†Ô∏è L·ªói ƒë·ªçc file JSON, kh·ªüi t·∫°o m·ªõi ho√†n to√†n."
            masterData = [:]
        }
    }

    def finalData = [:]
    int unusedCount = 0
    int newCount = 0

    // 1. Ph√¢n lo·∫°i key c≈©
    masterData.each { key, comment ->
        def cleanKey = key.replace(" [UNUSED]", "")
        if (!currentProjectKeys.contains(cleanKey)) {
            finalData[cleanKey + " [UNUSED]"] = comment
            unusedCount++
        } else {
            finalData[cleanKey] = comment
        }
    }

    // 2. Th√™m key m·ªõi xu·∫•t hi·ªán
    currentProjectKeys.each { key ->
        if (!finalData.containsKey(key)) {
            finalData[key] = "Ch∆∞a c√≥ ch√∫ th√≠ch"
            newCount++
            println "   ${GREEN}+ New Key:${RESET} ${key}"
        }
    }

    // 3. Ghi file v√† Fix Unicode
    def sortedData = finalData.sort { it.key }
    def rawJson = JsonOutput.prettyPrint(JsonOutput.toJson(sortedData))
    def fixUnicode = rawJson.replaceAll(/\\u([0-9a-fA-F]{4})/) { match, code ->
        return (char) Integer.parseInt(code, 16)
    }

    jsonFile.setText(fixUnicode, "UTF-8")

    // --- LOG K·∫æT TH√öC ---
    println "   ‚úÖ C·∫≠p nh·∫≠t xong: ${CYAN}${jsonFile.name}${RESET}"
    println "   üìà Th·ªëng k√™: ${GREEN}${newCount} M·ªõi${RESET} | ${YELLOW}${unusedCount} Kh√¥ng d√πng${RESET} | ${CYAN}${currentProjectKeys.size()} ƒêang s·ª≠ d·ª•ng${RESET}"
    println "${PURPLE}--------------------------------------------------${RESET}\n"
}

ext.getModulePropByServiceNameList = { List<String> propsFilter, List<HashMap> dirListProps ->
    return dirListProps.findAll { HashMap prop ->
        if (prop.get("SERVICE_NAME") == null) return false
        if (!propsFilter.contains(prop.get("SERVICE_NAME"))) return false

        return true
    }
}

ext.getModulePropByServiceName = { String propFilter, List<HashMap> dirListProps ->
    return dirListProps.find { HashMap prop -> prop.SERVICE_NAME == propFilter}
}

ext.findSubProjectByServiceName = {String serviceName ->
    // 1. T√¨m trong t·∫•t c·∫£ c√°c project ƒë√£ ƒë∆∞·ª£c include
    def target = rootProject.subprojects.find { p ->
        // C√°ch n√†y an to√†n h∆°n: Ki·ªÉm tra tr·ª±c ti·∫øp property m√† kh√¥ng b·∫Øt project ph·∫£i evaluate xong
        p.hasProperty('SERVICE_NAME') && p.SERVICE_NAME == serviceName
    }

    if (target == null) {
        // In ra danh s√°ch c√°c SERVICE_NAME hi·ªán c√≥ ƒë·ªÉ b·∫°n d·ªÖ debug
        def availableServices = rootProject.subprojects
                .findAll { it.hasProperty('SERVICE_NAME') }
                .collect { it.SERVICE_NAME }

        throw new GradleException(
                "‚ùå Kh√¥ng t√¨m th·∫•y module: '${serviceName}'. \n" +
                "üîç C√°c service hi·ªán c√≥: ${availableServices} \n" +
                "üëâ H√£y ki·ªÉm tra file gradle.properties c·ªßa module ƒë√≠ch."
        )
    }
    return target
}

