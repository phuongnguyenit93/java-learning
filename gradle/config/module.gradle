import groovy.json.JsonOutput
import groovy.json.JsonSlurper

ext.getAndStoreModuleProps = {
    def GREEN = "\u001B[32m"
    def RESET = "\u001B[0m"
    def CYAN = "\u001B[36m"
    def BLUE = "\u001B[34m"

    logger.lifecycle("${BLUE}==================================================")
    logger.lifecycle("üîç [SCANNER] ƒêang l·∫≠p b·∫£n ƒë·ªì c√°c module trong d·ª± √°n...")
    logger.lifecycle("${BLUE}==================================================${RESET}")

    List<HashMap> dirListProps = new ArrayList<>()
    HashMap currentProjectKeys = [:]
    // L·∫•y danh s√°ch c√°c folder ch·ª©a gradle.properties (tr·ª´ root v√† build)
    List<File> folderList = fileTree(rootDir) {
        include '**/gradle.properties'
        exclude 'gradle.properties' // Lo·∫°i tr·ª´ file ·ªü root
        exclude '**/build'
    }.files.unique()
            .collect { it.parentFile }

    logger.lifecycle("üìÇ T√¨m th·∫•y ${CYAN}${folderList.size()}${RESET} th∆∞ m·ª•c ch·ª©a c·∫•u h√¨nh.")

    folderList.eachWithIndex { File folder, Integer index ->
        File propFile = new File(folder, "gradle.properties")
        Properties props = new Properties()
        propFile.withInputStream { props.load(it) }

        // X√°c ƒë·ªãnh T√™n Module & ƒê∆∞·ªùng d·∫´n t∆∞∆°ng ƒë·ªëi
        String moduleName = props.getProperty("SERVICE_NAME") ?: folder.name

        // 1. X·ª≠ l√Ω RELATIVE_PATH (v√≠ d·ª•: services/order-service)
        String relativePath = rootDir.toPath()
                .relativize(folder.toPath()).toString()
                .replace('\\', '/')

        // 2. X·ª≠ l√Ω MODULE_PATH (v√≠ d·ª•: :services:order-service)
        String modulePath = relativePath.replace("/",":")

        HashMap<String, String> propMap = new HashMap(props)

        propMap.put("MODULE_PATH", modulePath)
        propMap.put("RELATIVE_PATH", relativePath)

        props.keySet().each { key ->
            def keyStr = key.toString()
            if (!currentProjectKeys.containsKey(keyStr)) {
                currentProjectKeys[keyStr] = [:]
            }
            // L∆∞u Map module -> path
            currentProjectKeys[keyStr][moduleName] = relativePath
        }

        dirListProps.add(propMap)

        def infoFile = new File(rootDir as File,"internal/info/module/module-info.json")
        if (!infoFile.exists()) infoFile.createNewFile()

        def jsonString = JsonOutput.prettyPrint(JsonOutput.toJson(dirListProps))
        infoFile.text = jsonString

        // Log t·ª´ng module ƒë∆∞·ª£c map th√†nh c√¥ng
        def serviceName = propMap.get("SERVICE_NAME") ?: "N/A"
        logger.lifecycle("   [${index + 1}] ${GREEN}${serviceName}${RESET} -> :${modulePath}")
    }

    logger.lifecycle("${BLUE}--------------------------------------------------")
    logger.lifecycle("‚ú® [SCAN COMPLETED] ƒê√£ n·∫°p xong ${CYAN}${dirListProps.size()}${RESET} b·ªô thu·ªôc t√≠nh v√†o b·ªô nh·ªõ.")
    logger.lifecycle("${BLUE}==================================================${RESET}\n")

    return [dirListProps,currentProjectKeys]
}


ext.addModule = {List<HashMap> dirListProps ->
    dirListProps.each { HashMap prop ->
        def modulePath = prop.get("MODULE_PATH")

        if (prop.IS_MICROSERVICE == 'TRUE') {
            include ":${modulePath}"
        }
    }
}

ext.injectTask = {
    def GREEN = "\u001B[32m"
    def YELLOW = "\u001B[33m"
    def RESET = "\u001B[0m"
    def CYAN = "\u001B[36m"
    def BLUE = "\u001B[34m"

    logger.lifecycle("${BLUE}==================================================")
    logger.lifecycle("üîç T·∫†O RA C√ÅC FILE TASK.GRADLE ·ªû MODULE V√Ä COPY C√ÅC TASK D√ÄNH RI√äNG CHO C√ÅC MODULE V√Ä B·ªé V√ÄO ƒê√ì")
    logger.lifecycle("${BLUE}==================================================${RESET}")

    logger.lifecycle("${BLUE}üöÄ [INJECT-ENGINE] B·∫Øt ƒë·∫ßu qu√° tr√¨nh qu√©t v√† ph√¢n ph·ªëi Task...${RESET}")

    HashMap<String, List<String>> taskContent = new HashMap()
    HashMap<String, List<String>> moduleContent = new HashMap()

    def taskListProp = [
            [type: "module", fileName: "module.gradle", propCheck: ""],
            [type: "env", fileName: "env.gradle", propCheck: "BUILD_ENV"],
            [type: "readme", fileName: "readme.gradle", propCheck: "BUILD_README"],
            [type: "properties", fileName: "properties.gradle", propCheck: "BUILD_YML"]
    ]

    def extractBlocks = { tagName, fileText ->
        def pattern = /(?s)\/\/ START_${tagName}\s*\n(.*?)\n\s*\/\/ END_${tagName}/
        def matcher = (fileText =~ pattern)
        return matcher.collect { it[1].trim() }
    }

    // Giai ƒëo·∫°n 1: Tr√≠ch xu·∫•t t·ª´ Template
    logger.lifecycle("${CYAN}üìÇ B∆∞·ªõc 1: Tr√≠ch xu·∫•t d·ªØ li·ªáu t·ª´ c√°c file Template...${RESET}")
    taskListProp.each { task ->
        String fileName = task.get("fileName")
        def templateFile = file("${rootDir}/gradle/task/${fileName}")

        if (templateFile.exists()) {
            def fileText = templateFile.text
            def tasks = extractBlocks("MY_TASK", fileText)
            def modules = extractBlocks("MY_MODULE_APPLY", fileText)

            taskContent.put(task.get("type"), tasks)
            moduleContent.put(task.get("type"), modules)
            logger.lifecycle("   + [${task.type}]: T√¨m th·∫•y ${GREEN}${tasks.size()}${RESET} tasks v√† ${GREEN}${modules.size()}${RESET} module blocks.")
        } else {
            logger.lifecycle("   + [${task.type}]: ${YELLOW}C·∫£nh b√°o: Kh√¥ng t√¨m th·∫•y file ${fileName}${RESET}")
        }
    }

    // Giai ƒëo·∫°n 2: Ph√¢n ph·ªëi xu·ªëng subprojects
    logger.lifecycle("${CYAN}üèóÔ∏è  B∆∞·ªõc 2: Ti·∫øn h√†nh Inject file task.gradle v√†o c√°c subprojects...${RESET}")
    subprojects { project ->
        def propFile = file("${project.projectDir}/gradle.properties")
        if (!propFile.exists()) return

        def props = new Properties()
        propFile.withInputStream { props.load(it) }
        def serviceName = props.getProperty("SERVICE_NAME")
        def isInjectTask = props.getProperty("INJECT_TASK_AUTO")

        if (serviceName != null && !serviceName.isEmpty() && isInjectTask == "TRUE") {
            String moduleContentFinal = ""
            String taskContentFinal = ""
            def injectedTypes = []

            taskListProp.each { task ->
                def propCheckKey = task.get("propCheck")
                def isPropActive = (propCheckKey == "" || props.getProperty(propCheckKey) == "TRUE")

                if (isPropActive) {
                    def tasksToInject = taskContent[task.get("type")] ?: []
                    def moduleToInject = moduleContent[task.get("type")] ?: []

                    if (!tasksToInject.isEmpty() || !moduleToInject.isEmpty()) {
                        injectedTypes << task.get("type")

                        moduleToInject.each { String code -> moduleContentFinal += code + "\n" }

                        tasksToInject.each { String originalCode ->
                            def namePattern = /(?:tasks\.register\s*\(?\s*['"]|task\s+)(\w+)/
                            def nameMatcher = (originalCode =~ namePattern)

                            if (nameMatcher.find()) {
                                def originalTaskName = nameMatcher.group(1)
                                def newTaskName = "${originalTaskName}_${serviceName}"
                                def customizedCode = originalCode.replaceAll(/(?<!ext\.)\b${originalTaskName}\b/, newTaskName)
                                taskContentFinal += "// Injected from ${task.type}: ${originalTaskName}\n" + customizedCode + "\n\n"
                            }
                        }
                    }
                }
            }

            def targetFile = file("${project.projectDir}/task.gradle")
            if (!moduleContentFinal.isEmpty() || !taskContentFinal.isEmpty()) {
                if (!targetFile.exists()) targetFile.createNewFile()
                targetFile.text = "// AUTO GENERATED FILE - DO NOT EDIT\n\n" + moduleContentFinal + "\n" + taskContentFinal
                logger.lifecycle("   ‚úÖ Module [${GREEN}${serviceName}${RESET}]: ƒê√£ inject th√†nh c√¥ng (${injectedTypes.join(', ')})")
            }
        } else if (serviceName != null) {
             // Log nh·ªØng module b·ªã b·ªè qua nh∆∞ng c√≥ SERVICE_NAME ƒë·ªÉ d·ªÖ ki·ªÉm so√°t
//             logger.lifecycle("   ‚è© Module [${serviceName}]: B·ªè qua (INJECT_TASK_AUTO=false)")
        }
    }
    logger.lifecycle("${BLUE}==================================================${RESET}")
}

ext.getModulePropByKeyValue = { String key, String value, List<HashMap> dirListProps ->
    return dirListProps.findAll { HashMap prop ->
        if (value == null) {
            if (prop.containsKey(key)) return true
        } else {
            if (prop[key] != value) return false
        }

        return true
    }
}

ext.getAllModuleProperties = { Map currentProjectKeys ->
    def GREEN = "\u001B[32m"
    def YELLOW = "\u001B[33m"
    def RESET = "\u001B[0m"
    def CYAN = "\u001B[36m"
    def PURPLE = "\u001B[35m"

    logger.lifecycle("${PURPLE}==================================================")
    logger.lifecycle("${PURPLE}üìë [PROPERTY-DICTIONARY] ƒêang ph√¢n t√≠ch v√† c·∫≠p nh·∫≠t t·ª´ ƒëi·ªÉn thu·ªôc t√≠nh...${RESET}")
    logger.lifecycle("${PURPLE}==================================================${RESET}")

    def descFile = new File(rootDir, "internal/info/properties/description-properties.json")
    def infoFile = new File(rootDir, "internal/info/properties/info-properties.json")

    // --- X·ª¨ L√ù FILE 1: description-properties.json ---
    def oldDescData = [:]
    if (descFile.exists()) {
        try {
            def parsed = new JsonSlurper().parseText(descFile.getText("UTF-8"))
            if (parsed instanceof Map) oldDescData = new LinkedHashMap(parsed)
        } catch (e) { oldDescData = [:] }
    }

    def newDescData = [:]
    int statusChanged = 0
    int newAdded = 0

    // Gi·ªØ Description v√† c·∫≠p nh·∫≠t Status
    oldDescData.each { key, meta ->
        def metaMap = new LinkedHashMap(meta as Map)
        def oldStatus = metaMap.STATUS
        def newStatus = currentProjectKeys.containsKey(key) ? "USING" : "NOT-USED"

        if (oldStatus != newStatus) statusChanged++

        newDescData[key] = [
                "DESCRIPTION": metaMap.DESCRIPTION ?: "Ch∆∞a c√≥ ch√∫ th√≠ch",
                "STATUS": newStatus
        ]
    }

    // Th√™m c√°c key m·ªõi xu·∫•t hi·ªán trong code
    currentProjectKeys.keySet().each { key ->
        if (!newDescData.containsKey(key)) {
            newDescData[key] = ["DESCRIPTION": "Ch∆∞a c√≥ ch√∫ th√≠ch", "STATUS": "USING"]
            newAdded++
            logger.lifecycle("   ${GREEN}+ New Property Found:${RESET} ${key}")
        }
    }

    // --- X·ª¨ L√ù FILE 2: info-properties.json ---
    def newInfoData = [:]
    currentProjectKeys.each { key, modulesMap ->
        newInfoData[key] = ["MODULES": modulesMap.sort()]
    }

    // --- GHI FILE V√Ä FIX UNICODE ---
    [[file: descFile, data: newDescData], [file: infoFile, data: newInfoData]].each { item ->
        def rawJson = JsonOutput.prettyPrint(JsonOutput.toJson(item.data.sort()))
        def fixUnicode = rawJson.replaceAll(/\\u([0-9a-fA-F]{4})/) { match, code ->
            return (char) Integer.parseInt(code, 16)
        }
        item.file.setText(fixUnicode, "UTF-8")
    }

    // --- LOG T·ªîNG K·∫æT ---
    logger.lifecycle("   üìù ${CYAN}Description File:${RESET} ƒê√£ n·∫°p ${newDescData.size()} keys (${GREEN}+${newAdded} m·ªõi${RESET}, ${YELLOW}${statusChanged} ƒë·ªïi tr·∫°ng th√°i${RESET})")
    logger.lifecycle("   üìÇ ${CYAN}Info File:${RESET} ƒê√£ c·∫≠p nh·∫≠t b·∫£n ƒë·ªì s·ª≠ d·ª•ng cho ${newInfoData.size()} thu·ªôc t√≠nh.")
    logger.lifecycle("${PURPLE}--------------------------------------------------${RESET}\n")
}

ext.getModulePropByServiceNameList = { List<String> propsFilter, List<HashMap> dirListProps ->
    return dirListProps.findAll { HashMap prop ->
        if (prop.get("SERVICE_NAME") == null) return false
        if (!propsFilter.contains(prop.get("SERVICE_NAME"))) return false

        return true
    }
}

ext.getModulePropByServiceName = { String propFilter, List<HashMap> dirListProps ->
    return dirListProps.find { HashMap prop -> prop.SERVICE_NAME == propFilter}
}

ext.findSubProjectByServiceName = {String serviceName ->
    // 1. T√¨m trong t·∫•t c·∫£ c√°c project ƒë√£ ƒë∆∞·ª£c include
    def target = rootProject.subprojects.find { p ->
        // C√°ch n√†y an to√†n h∆°n: Ki·ªÉm tra tr·ª±c ti·∫øp property m√† kh√¥ng b·∫Øt project ph·∫£i evaluate xong
        p.hasProperty('SERVICE_NAME') && p.SERVICE_NAME == serviceName
    }

    if (target == null) {
        // In ra danh s√°ch c√°c SERVICE_NAME hi·ªán c√≥ ƒë·ªÉ b·∫°n d·ªÖ debug
        def availableServices = rootProject.subprojects
                .findAll { it.hasProperty('SERVICE_NAME') }
                .collect { it.SERVICE_NAME }

        throw new GradleException(
                "‚ùå Kh√¥ng t√¨m th·∫•y module: '${serviceName}'. \n" +
                "üîç C√°c service hi·ªán c√≥: ${availableServices} \n" +
                "üëâ H√£y ki·ªÉm tra file gradle.properties c·ªßa module ƒë√≠ch."
        )
    }
    return target
}

