apply from: "${rootDir}/gradle/config/module.gradle"

ext.buildDefaultEnvStructure = { List<HashMap> envProps ->
    envProps.each { props ->
        def GREEN = "\u001B[32m"
        def YELLOW = "\u001B[33m"
        def RESET = "\u001B[0m"
        def CYAN = "\u001B[36m"
        def GRAY = "\u001B[90m"

        File baseDir = new File(rootDir,props.get("RELATIVE_PATH")?.toString())
        String serviceName = props.get("SERVICE_NAME") ?: baseDir.name

        File env = new File(baseDir, ".env")

        // 1. X·ª≠ l√Ω t·∫°o file .env
        if (!env.exists()) {
            try {
                env.createNewFile()
                env.text = "# Environment variables for ${serviceName}\n"
                logger.lifecycle("‚ú® [${CYAN}${serviceName}${RESET}] ${GREEN}ƒê√£ kh·ªüi t·∫°o file .env m·ªõi.${RESET}")
            } catch (Exception e) {
                logger.error("‚ùå [${serviceName}] L·ªói t·∫°o file: ${e.message}")
                return
            }
        } else {
            logger.lifecycle("‚úîÔ∏è  [${CYAN}${serviceName}${RESET}] C·∫•u tr√∫c file .env ƒë√£ t·ªìn t·∫°i.")
        }

        // 2. Ki·ªÉm tra ƒëi·ªÅu ki·ªán Docker Profile
        if (props.get("BUILD_ENV_DOCKER_PROFILE")?.toString() == "TRUE") {
            String content = env.text
            boolean hasProfile = content.lines().any { line ->
                line.trim().startsWith("DOCKER_PROFILE=")
            }

            if (!hasProfile) {
                // ƒê·∫£m b·∫£o file k·∫øt th√∫c b·∫±ng xu·ªëng d√≤ng tr∆∞·ªõc khi append ƒë·ªÉ tr√°nh d√≠nh ch·ªØ
                if (!content.endsWith("\n") && content.length() > 0) env.append("\n")
                env.append("DOCKER_PROFILE=\n")
                logger.lifecycle("   ‚îî‚îÄ ${YELLOW}ƒê√£ b·ªï sung bi·∫øn:${RESET} DOCKER_PROFILE (Docker Mode)")
            } else {
                logger.lifecycle("   ‚îî‚îÄ ${GREEN}X√°c nh·∫≠n:${RESET} DOCKER_PROFILE ƒë√£ c√≥ s·∫µn.")
            }
        } else {
            // Log nh·∫π nh√†ng ƒë·ªÉ bi·∫øt module n√†y b·ªè qua b∆∞·ªõc check profile
            logger.lifecycle("   ‚îî‚îÄ ${GRAY}B·ªè qua check Profile (BUILD_ENV_DOCKER_PROFILE != TRUE)${RESET}")
        }
    }
}

ext.buildProfileEnvStructure = { List<HashMap> envProps ->
    def GREEN = "\u001B[32m"
    def CYAN = "\u001B[36m"
    def RESET = "\u001B[0m"
    def YELLOW = "\u001B[33m"

    logger.lifecycle("${CYAN}==================================================")
    logger.lifecycle("${CYAN}üìÅ [ENV-STRUCTURE]${RESET} ƒêang kh·ªüi t·∫°o c·∫•u tr√∫c file .env cho ${envProps.size()} module...")
    logger.lifecycle("${CYAN}==================================================${RESET}")

    envProps.each { props ->
        File baseDir = new File (rootDir,props.get("RELATIVE_PATH") as String)
        String serviceName = props.get("SERVICE_NAME") ?: baseDir.name

        List<String> profiles = gradle.extensions.extraProperties.get("profiles") as List<String>
        int createdCount = 0

        // 1. T·∫°o c√°c file .env theo profile (dev, prod, loc...)
        profiles.each { profile ->
            File envProfile = new File(baseDir, ".env.${profile}")
            if (!envProfile.exists()) {
                envProfile.createNewFile()
                createdCount++
            }
        }

        // Log k·∫øt qu·∫£ cho t·ª´ng module
        if (createdCount > 0) {
            logger.lifecycle("   ‚ú® Module [${GREEN}${serviceName}${RESET}]: ƒê√£ t·∫°o m·ªõi ${YELLOW}${createdCount}${RESET} file .env.")
        } else {
            logger.lifecycle("   ‚úîÔ∏è  Module [${GREEN}${serviceName}${RESET}]: C·∫•u tr√∫c .env profile ƒë√£ ƒë·∫ßy ƒë·ªß.")
        }
    }

    logger.lifecycle("${CYAN}--------------------------------------------------${RESET}")
}

ext.generateEnvFile = { List<HashMap> modulePropsList, String serviceName ->
    def GREEN = "\u001B[32m"
    def YELLOW = "\u001B[33m"
    def RESET = "\u001B[0m"
    def BLUE = "\u001B[34m"
    def CYAN = "\u001B[36m"

    logger.lifecycle("${BLUE}==================================================")
    logger.lifecycle("üîç GENERATED V√Ä UPDATE N·ªòI DUNG ENV C·∫¶N CHO DOCKER-COMPOSE V√Ä APPLICATION.YML (KH√îNG T·ªîN H·∫†I FILE G·ªêC)")
    logger.lifecycle("${BLUE}==================================================${RESET}")

    HashMap props = ext.getModulePropByServiceName(serviceName, modulePropsList)
    if (props == null || props.isEmpty()) return

    def moduleDir = new File (rootDir,props.get("RELATIVE_PATH") as String).path
//    List<String> profiles = gradle.extensions.extraProperties.get("profiles") as List<String>
//    List<String> envProfile = profiles.collect{env -> ".env.${env}"} as List<String>
//    def envFiles = [".env", *envProfile]
    def envFiles = [".env"]

    logger.lifecycle("${BLUE}üåê [ENV-SYNC]${RESET} ƒêang ƒë·ªìng b·ªô h√≥a m√¥i tr∆∞·ªùng cho: ${CYAN}${serviceName}${RESET}")

    // 1. Qu√©t Master Keys
    def masterKeys = [] as Set
    [file("${moduleDir}/src/main/resources/application-merged.yml"), file("${moduleDir}/docker-compose.yml")].each { f ->
        if (f.exists()) {
            // L·∫•y ph·∫ßn ${....}
            def matcher = (f.text =~ /\$\{\s*([A-Z0-9_]+)(?::.*)?\s*\}/)
            matcher.each { masterKeys << it[1] }
        }
    }
    logger.lifecycle("   üß© T√¨m th·∫•y ${YELLOW}${masterKeys.size()}${RESET} bi·∫øn m√¥i tr∆∞·ªùng c·∫ßn thi·∫øt t·ª´ YAML/Docker.")

    // 2. L·∫•y Map gi√° tr·ªã mu·ªën ƒë√®
    def overrideProps = project.ext.getModuleDependEnvPath(props, modulePropsList) ?: [:]

    // T·∫°o m·ªôt t·∫≠p h·ª£p t·∫•t c·∫£ c√°c keys: Nh·ªØng g√¨ khai b√°o trong code + Nh·ªØng g√¨ c√≥ trong overrideProps
    logger.lifecycle("   üß© T·ªïng c·ªông ${YELLOW}${masterKeys.size()}${RESET} bi·∫øn (Code: ${masterKeys.size()}, Override: ${overrideProps.size()})")

    // 3. X·ª≠ l√Ω t·ª´ng file
    envFiles.each { fileName ->
        def targetFile = file("${moduleDir}/${fileName}")
        def currentContent = [:]
        def updatedCount = 0

        if (targetFile.exists()) {
            targetFile.eachLine { line ->
                if (line.trim() && !line.startsWith("#") && line.contains("=")) {
                    def parts = line.split("=", 2)
                    currentContent[parts[0].trim()] = parts.length > 1 ? parts[1].trim() : ""
                }
            }
        }

        def newLines = [
                "# ----------------------------------------------------------------",
                "# Auto-generated for: ${serviceName}",
                "# Sync Date: ${new Date().format('yyyy-MM-dd HH:mm:ss')}",
                "# ----------------------------------------------------------------"
        ]

        masterKeys.sort().each { key ->
            def finalValue = ""

            if (overrideProps.containsKey(key)) {
                finalValue = overrideProps[key]
                updatedCount++
            } else if (currentContent.containsKey(key)) {
                finalValue = currentContent[key]
            }

            newLines << "${key}=${finalValue}"
        }

        targetFile.text = newLines.join("\n")
        logger.lifecycle("   üìù ${GREEN}Generated:${RESET} ${fileName} (${masterKeys.size()} keys, ${updatedCount} auto-filled)")
    }

    // 4. Example file
    def exampleFile = file("${moduleDir}/.env.example")
    exampleFile.text = "# Sample values - Please fill manually\n" +
            masterKeys.sort().collect { "${it}=your-value-here" }.join("\n")

    logger.lifecycle("${GREEN}‚úÖ Done!${RESET} File .env.example ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t c·∫•u tr√∫c m·ªõi nh·∫•t.")
    logger.lifecycle("--------------------------------------------------")
}

ext.getModuleDependEnvPath = { HashMap prop, List<HashMap> dirListProps ->
    def CYAN = "\u001B[36m"
    def RESET = "\u001B[0m"
    def YELLOW = "\u001B[33m"
    def GREEN = "\u001B[32m"
    def BLUE = "\u001B[34m"

    logger.lifecycle("${BLUE}==================================================")
    logger.lifecycle("üîç T√åM KI·∫æM V√Ä THI·∫æT L·∫¨P C√ÅC PATH C·ª¶A MODULE ƒê·ªÇ D√ôNG CHO DOCKER-COMPOSE")
    logger.lifecycle("${BLUE}==================================================${RESET}")

    // 1. L·∫•y danh s√°ch service ph·ª• thu·ªôc
    List<String> microserviceList = prop.get("BUILD_ENV_PATH_MODULE_DEPEND")?.toString()?.split(',') as List<String> ?: []
    String moduleName = prop.get("SERVICE_NAME")

    // Th√™m ch√≠nh n√≥ v√†o danh s√°ch ƒë·ªÉ l·∫•y path c·ªßa ch√≠nh m√¨nh lu√¥n
    if (moduleName && !microserviceList.contains(moduleName)) {
        microserviceList.add(moduleName)
    }

    logger.lifecycle("${CYAN}üîç [ENV-PATH]${RESET} ƒêang thu th·∫≠p ƒë∆∞·ªùng d·∫´n ph·ª• thu·ªôc cho: ${GREEN}${moduleName}${RESET}")

    // 2. L·ªçc th√¥ng tin props t·ª´ danh s√°ch t·ªïng
    List<HashMap> filterMicroserviceProps = ext.getModulePropByServiceNameList(microserviceList, dirListProps)
    HashMap moduleEnvPath = new HashMap()

    def projectRootDir = rootDir.path.replace(File.separator,"/")
    moduleEnvPath.PROJECT_ROOT = projectRootDir
    logger.lifecycle("   + Setting: ${YELLOW}PROJECT_ROOT${RESET} c·ªßa ${YELLOW}${moduleName}${RESET} -> ${projectRootDir}")

    filterMicroserviceProps.each { service ->
        def sName = service.get("SERVICE_NAME")
        def relativePath = service.get("RELATIVE_PATH")
        def modPath = service.get("MODULE_PATH")

        moduleEnvPath["${sName}_ABSOLUTE_PATH"] = rootDir.path.replace(File.separator,"/") + "/" + relativePath
        moduleEnvPath["${sName}_RELATIVE_PATH"] = relativePath
        moduleEnvPath["${sName}_MODULE_PATH"] = modPath

        logger.lifecycle("   + Found: ${YELLOW}${sName}${RESET} -> ${relativePath}")
    }

    // Ki·ªÉm tra n·∫øu s·ªë l∆∞·ª£ng t√¨m th·∫•y √≠t h∆°n s·ªë l∆∞·ª£ng y√™u c·∫ßu
    if (filterMicroserviceProps.size() < microserviceList.size()) {
        logger.lifecycle("   ${YELLOW}‚ö†Ô∏è  Warning:${RESET} M·ªôt s·ªë service ph·ª• thu·ªôc kh√¥ng t√¨m th·∫•y th√¥ng tin trong dirListProps!")
    }

    // D√≤ng t·ªïng k·∫øt cu·ªëi c√πng
    logger.lifecycle("${GREEN}‚ú® [COMPLETED]${RESET} ƒê√£ thi·∫øt l·∫≠p th√†nh c√¥ng ${CYAN}${moduleEnvPath.size()}${RESET} bi·∫øn m√¥i tr∆∞·ªùng cho ${GREEN}${moduleName}${RESET}.")
    logger.lifecycle("${BLUE}--------------------------------------------------${RESET}\n")

    return moduleEnvPath
}
