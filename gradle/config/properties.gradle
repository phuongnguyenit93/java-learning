import org.yaml.snakeyaml.Yaml
import org.yaml.snakeyaml.DumperOptions

apply from: "${rootDir}/gradle/config/module.gradle"

def getBaseDirProps (HashMap props) {
    def baseDir = new File (rootDir,props.get("RELATIVE_PATH"))
    return ["src/main/resources", ""]
            .collect { new File(baseDir,it)}
            .find { it.exists() }
}

static def mergeMaps (Map base,Map override) {
    override.each { key, value ->
        if (base.containsKey(key)) {
            if (value instanceof Map && base[key] instanceof Map) {
                mergeMaps(base[key], value)
            } else if (base[key] != value) {
                base[key] = value // Kh√°c value th√¨ ƒë√® l·∫°i gi√° tr·ªã
            }
        } else {
            base[key] = value // Key m·ªõi th√¨ th√™m v√†o
        }
    }
}

ext.buildProfilePropsFile = { List<HashMap> appProps ->
    def GREEN = "\u001B[32m"
    def YELLOW = "\u001B[33m"
    def CYAN = "\u001B[36m"
    def RESET = "\u001B[0m"
    def RED = "\u001B[31m"
    def BLUE = "\u001B[34m"
    def BOLD = "\u001B[1m"

    logger.lifecycle("${BLUE}${BOLD}==================================================")
    logger.lifecycle("üîç KH·ªûI T·∫†O APPLICATION.YML T·∫†I C√ÅC MODULE CH∆ØA C√ì")
    logger.lifecycle("${BLUE}==================================================${RESET}")

    logger.lifecycle("${CYAN}üöÄ [CONFIG-INIT]${RESET} ƒêang ki·ªÉm tra c·∫•u h√¨nh application.yml cho ${appProps.size()} module...")

    appProps.each { props ->
        def moduleName = props.get("SERVICE_NAME") ?: props.get("RELATIVE_PATH")
        def baseFile = file("${rootDir}/info/module/file-based.yml")
        def baseDir = getBaseDirProps(props)
        def configFile = file("${baseDir}/application.yml")

        // 1. Ki·ªÉm tra file m·∫´u (base-file) tr∆∞·ªõc
        if (!baseFile.exists()) {
            logger.lifecycle("${RED}‚ùå [ERROR]${RESET} Kh√¥ng t√¨m th·∫•y file m·∫´u t·∫°i: ${baseFile.path}")
            return // Tho√°t s·ªõm n·∫øu kh√¥ng c√≥ file g·ªëc ƒë·ªÉ copy
        }

        // 2. X·ª≠ l√Ω logic t·∫°o file
        if (configFile.exists()) {
            // D√πng d·∫•u m≈©i t√™n m·ªù h∆°n cho c√°c file ƒë√£ t·ªìn t·∫°i ƒë·ªÉ tr√°nh lo√£ng log
            logger.lifecycle("  ${YELLOW}‚è© [SKIP]${RESET} Module [${moduleName}]: application.yml ƒë√£ t·ªìn t·∫°i.")
        } else {
            try {
                // ƒê·∫£m b·∫£o th∆∞ m·ª•c cha t·ªìn t·∫°i tr∆∞·ªõc khi t·∫°o file
                if (!configFile.parentFile.exists()) {
                    configFile.parentFile.mkdirs()
                }

                configFile.createNewFile()
                configFile.text = baseFile.text

                logger.lifecycle("  ${GREEN}‚ú® [CREATED]${RESET} Module [${moduleName}]: ƒê√£ kh·ªüi t·∫°o file t·ª´ file-based.yml")
                logger.lifecycle("             ‚îî‚îÄ Path: ${configFile.path}")
            } catch (Exception e) {
                logger.lifecycle("${RED}‚ùå [FAILED]${RESET} Kh√¥ng th·ªÉ t·∫°o file cho ${moduleName}: ${e.message}")
            }
        }
    }
    logger.lifecycle("${CYAN}--------------------------------------------------${RESET}")
}

ext.combineBuildYaml = { List<HashMap> folderPropsList, String serviceName ->
    def GREEN = "\u001B[32m"
    def YELLOW = "\u001B[33m"
    def CYAN = "\u001B[36m"
    def RESET = "\u001B[0m"
    def BLUE = "\u001B[34m"
    def RED = "\u001B[31m"

    logger.lifecycle("${BLUE}==================================================")
    logger.lifecycle("üîç G·ªòP C√ÅC APPLICATION.YML T·∫†I C√ÅC MODULE L·ªÜ THU·ªòC V√ÄO MODULE G·ªêC")
    logger.lifecycle("${BLUE}==================================================${RESET}")

    logger.lifecycle("${BLUE}üß© [YAML-MERGE]${RESET} B·∫Øt ƒë·∫ßu g·ªôp file c·∫•u h√¨nh cho Service: ${CYAN}${serviceName}${RESET}")

    HashMap props = ext.getModulePropByServiceName(serviceName, folderPropsList)
    List<String> microserviceList = props.get("BUILD_YML_MODULE_DEPEND")?.toString()?.split(',') as List<String> ?: []

    if (props.isEmpty()) {
        logger.lifecycle("${RED}‚ùå [ERROR]${RESET} Kh√¥ng t√¨m th·∫•y c·∫•u h√¨nh cho service: ${serviceName}")
        return
    }

    if (microserviceList.isEmpty()) {
        logger.lifecycle("${CYAN}‚ÑπÔ∏è [STANDALONE]${RESET} Module ${GREEN}${serviceName}${RESET}: Kh√¥ng c√≥ module ph·ª• thu·ªôc. S·ª≠ d·ª•ng application.yml m·∫∑c ƒë·ªãnh.")
    }

    List<HashMap> microserviceProp = ext.getModulePropByServiceNameList(microserviceList, folderPropsList)
    List<File> sourceFiles = microserviceProp.collect { prop ->
        def baseDir = getBaseDirProps(prop)
        return new File(baseDir, "application.yml")
    }

    File baseResourceDir = getBaseDirProps(props)
    File targetFile = new File(baseResourceDir, "application.yml")

    // Ki·ªÉm tra targetFile g·ªëc
    if (!targetFile.exists()) {
        logger.lifecycle("${RED}‚ùå [ERROR]${RESET} Kh√¥ng t√¨m th·∫•y file g·ªëc t·∫°i: ${targetFile.path}")
        return
    }

    // X√°c ƒë·ªãnh ƒë∆∞·ªùng d·∫´n build (Safe-check cho Gradle layout)
    def buildDirFile = layout.buildDirectory.file("resources/main/application.yml").get().asFile
    File outputFileCheck = new File(baseResourceDir, "application-merged.yml")

    Yaml yaml = new Yaml()
    def finalDocsMap = [:]

    // Helper l·∫•y profile
    def getProfileName = { doc ->
        if (doc == null) return "default"
        try {
            return doc.get("spring")?.get("config")?.get("activate")?.get("on-profile") ?: "default"
        } catch (Exception e) { return "default" }
    }

    // --- B·∫ÆT ƒê·∫¶U QU√Å TR√åNH G·ªòP ---

    // B∆∞·ªõc A: Load file g·ªëc l√†m g·ªëc t·ªça ƒë·ªô
    logger.lifecycle("   üì• Loading Base: ${CYAN}${targetFile.path}${RESET}")
    yaml.loadAll(targetFile.text).each { doc ->
        if (doc != null) finalDocsMap[getProfileName(doc)] = doc
    }

    // B∆∞·ªõc B: L·∫∑p qua t·ª´ng file ngu·ªìn
    sourceFiles.each { sFile ->
        if (sFile.exists()) {
            logger.lifecycle("   ‚ûï Merging: ${YELLOW}${sFile.path}${RESET} -> application.yml")
            yaml.loadAll(sFile.text).each { doc ->
                if (doc != null) {
                    def pName = getProfileName(doc)
                    if (finalDocsMap.containsKey(pName)) {
                        mergeMaps(finalDocsMap[pName], doc) // Gi·∫£ ƒë·ªãnh b·∫°n ƒë√£ c√≥ h√†m mergeMaps
                    } else {
                        finalDocsMap[pName] = doc
                    }
                }
            }
        } else {
            logger.lifecycle("   ${RED}‚ö†Ô∏è  Missing:${RESET} ${sFile.path} (B·ªè qua)")
        }
    }

    // --- XU·∫§T K·∫æT QU·∫¢ ---
    DumperOptions options = new DumperOptions()
    options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK)
    options.setExplicitStart(true)
    Yaml writer = new Yaml(options)

    [buildDirFile, outputFileCheck].each { output ->
        // ƒê·∫£m b·∫£o th∆∞ m·ª•c t·ªìn t·∫°i
        if (!output.parentFile.exists()) output.parentFile.mkdirs()

        String buildRelativePath = rootDir.toPath()
                .relativize(buildDirFile.toPath()).toString()
                .replace('\\', '/')

        output.withWriter('UTF-8') { out ->
            if (output == outputFileCheck) {
                out.write("# AUTO-GENERATED MERGED YAML\n")
                out.write("# THIS FILES NOT USING TO BUILD, THE NEEDED IS ALREADY BUILD\n")
                out.write("# You can check at ${buildRelativePath}\n")
                out.write("# Source: ${props.SERVICE_NAME}\n")
                out.write("# Dependencies: ${microserviceList.join(', ')}\n\n")
            }
            finalDocsMap.values().each { doc ->
                writer.dump(doc, out)
            }
        }
    }

    logger.lifecycle("${GREEN}‚úÖ [SUCCESS]${RESET} H·ª£p nh·∫•t th√†nh c√¥ng ${CYAN}${finalDocsMap.size()}${RESET} profiles: ${finalDocsMap.keySet().join(", ")}")
    logger.lifecycle("   üìç Check file: ${BLUE}${outputFileCheck.path}${RESET}")
    logger.lifecycle("--------------------------------------------------")
}



