import java.util.regex.Matcher

ext.getFolderProps = {
    List<HashMap> dirListProps = new ArrayList<>()

    List<File> folderList = fileTree(rootDir) {
        include '**/gradle.properties'
        exclude 'gradle.properties'
        exclude '**/build'

    }.files.unique()
            .collect { it.parentFile }

    folderList.eachWithIndex{ File folder, Integer index ->

        File propFile = new File(folder,"gradle.properties")
        def props = new Properties()
        propFile.withInputStream { props.load(it) }

        HashMap<String,String> propMap = new HashMap(props)

        String absolutePath = folder.absolutePath.replace(File.separator,"/")
        propMap.put("ABSOLUTE_PATH",absolutePath)

        String modulePath = (folder.absolutePath + File.separator)
                .replace(rootDir.absolutePath + File.separator, '')
                .replace(File.separator, ':').toString()
                .with {it.substring(0,it.length()-1)}
        propMap.put("MODULE_PATH",modulePath)

        String jarPath = modulePath.replace(":","/")
        propMap.put("JAR_PATH",jarPath)


        dirListProps.add(propMap)
    }

    return dirListProps
}


ext.addModule = {List<HashMap> dirListProps ->
    dirListProps.each { HashMap prop ->
        def modulePath = prop.get("MODULE_PATH")

        if (prop.IS_MICROSERVICE == 'true') {
            include ":${modulePath}"
        }
    }
}

ext.injectTask = {
    HashMap <String,List<Matcher>> taskContent = new HashMap()
    HashMap <String,List<Matcher>> moduleContent = new HashMap()

    def taskListProp = [
            [type: "module", fileName : "module.gradle", propCheck : ""],
            [type: "env", fileName : "env.gradle", propCheck : "BUILD_ENV"],
            [type: "readme", fileName : "readme.gradle", propCheck : "BUILD_README"],
            [type: "properties", fileName : "properties.gradle", propCheck : "BUILD_PROPERTIES"]
    ]

    def extractBlocks = { tagName , file ->
        def pattern = /(?s)\/\/ START_${tagName}\s*\n(.*?)\n\s*\/\/ END_${tagName}/
        def matcher = (file =~ pattern)
        return matcher.collect { it[1].trim() }
    }

    taskListProp.each {task ->
        String fileName = task.get("fileName")
        def fileTask = file("${rootDir}/gradle/task/${fileName}").text

        taskContent.put(task.get("type"),extractBlocks("MY_TASK",fileTask))
        moduleContent.put(task.get("type"),extractBlocks("MY_MODULE_APPLY",fileTask))
    }

    subprojects { project ->
        def propFile = file("${project.projectDir}/gradle.properties")
        if (!propFile.exists()) return

        def props = new Properties()
        propFile.withInputStream { props.load(it) }
        def serviceName = props.getProperty("SERVICE_NAME")
        def isInjectTask = props.getProperty("INJECT_TASK_AUTO")

        if (serviceName != null && !serviceName.isEmpty() && isInjectTask == "true") {
            String moduleContentFinal = ""
            String taskContentFinal = ""

            taskListProp.each {task ->
                def propCheck = props.getProperty(task.get("propCheck"))

                if (task.propCheck != "" && propCheck != "true") {
                    println "‚ö†Ô∏è Module [${serviceName}]: B·ªè qua build task ${task.get("type")} v√¨ ${task.get("propCheck")} kh√¥ng c√≥"
                    return
                } else {
                    def tasksToInject = taskContent[task.get("type")]
                    def moduleToInject = moduleContent[task.get("type")]

                    moduleToInject.each {String matcher ->
                        moduleContentFinal += matcher
                        moduleContentFinal += "\n"
                    }

                    tasksToInject.each { String originalCode ->
                        def namePattern = /(?:tasks\.register\s*\(?\s*['"]|task\s+)(\w+)/
                        def nameMatcher = (originalCode =~ namePattern)

                        if (nameMatcher.find()) {
                            def originalTaskName = nameMatcher.group(1)
                            def newTaskName = "${originalTaskName}_${serviceName}"

                            def customizedCode = originalCode.replaceAll(/(?<!ext\.)\b${originalTaskName}\b/, newTaskName)
                            taskContentFinal += "// Injected: ${originalTaskName}\n\n" + customizedCode + "\n\n"
                        }
                    }
                }
            }

            def targetFile = file("${project.projectDir}/task.gradle")
            if (!targetFile.exists()) targetFile.createNewFile()

            if (!moduleContentFinal.isEmpty() && !taskContentFinal.isEmpty()) {
                targetFile.text = moduleContentFinal + "\n" + taskContentFinal
                println "‚úÖ Module [${serviceName}]: ƒê√£ ch√®n c√°c task m·ªõi."
            } else {
                println "‚ùå Kh√¥ng t√¨m th·∫•y n·ªôi dung n√†o ƒë·ªÉ inject!"
                return
            }
        } else {
            println "‚ö†Ô∏è Module [${serviceName ?: project.path}]: B·ªè qua v√¨ kh√¥ng th·∫•y SERVICE_NAME ho·∫∑c kh√¥ng ƒë∆∞·ª£c ph√©p inject task"
        }
    }
}

ext.getModulePropByKeyValue = { String key, String value, List<HashMap> dirListProps ->
    return dirListProps.findAll { HashMap prop ->
        if (value == null) {
            if (prop.containsKey(key)) return true
        } else {
            if (prop[key] != value) return false
        }

        return true
    }
}

ext.getModulePropByServiceNameList = { List<String> propsFilter, List<HashMap> dirListProps ->
    return dirListProps.findAll { HashMap prop ->
        if (prop.get("SERVICE_NAME") == null) return false
        if (!propsFilter.contains(prop.get("SERVICE_NAME"))) return false

        return true
    }
}

ext.getModulePropByServiceName = { String propFilter, List<HashMap> dirListProps ->
    return dirListProps.find { HashMap prop -> prop.SERVICE_NAME == propFilter}
}

ext.findSubProjectByServiceName = {String serviceName ->
    // 1. T√¨m trong t·∫•t c·∫£ c√°c project ƒë√£ ƒë∆∞·ª£c include
    def target = rootProject.subprojects.find { p ->
        // C√°ch n√†y an to√†n h∆°n: Ki·ªÉm tra tr·ª±c ti·∫øp property m√† kh√¥ng b·∫Øt project ph·∫£i evaluate xong
        p.hasProperty('SERVICE_NAME') && p.SERVICE_NAME == serviceName
    }

    if (target == null) {
        // In ra danh s√°ch c√°c SERVICE_NAME hi·ªán c√≥ ƒë·ªÉ b·∫°n d·ªÖ debug
        def availableServices = rootProject.subprojects
                .findAll { it.hasProperty('SERVICE_NAME') }
                .collect { it.SERVICE_NAME }

        throw new GradleException(
                "‚ùå Kh√¥ng t√¨m th·∫•y module: '${serviceName}'. \n" +
                "üîç C√°c service hi·ªán c√≥: ${availableServices} \n" +
                "üëâ H√£y ki·ªÉm tra file gradle.properties c·ªßa module ƒë√≠ch."
        )
    }
    return target
}

