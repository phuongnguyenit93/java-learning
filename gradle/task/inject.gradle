apply from: "${rootDir}/gradle/config/modules.gradle"

import org.yaml.snakeyaml.Yaml
import org.yaml.snakeyaml.DumperOptions

tasks.register('injectTaskToModule') {
    project.ext.injectTask()
}

tasks.register('cleanupSpecificFiles') {
    group = 'verification'
    description = 'Tìm và xóa các file dựa trên tên tham số nhập vào'

    doFirst {
        def targetName = "module.properties"

        if (!targetName) {
            throw new GradleException("Vui lòng nhập tên file cần xóa. Ví dụ: gradlew cleanupSpecificFiles -PfileName=test.txt")
        }

        println "--- Đang quét và xóa file: ${targetName} ---"

        // Duyệt qua tất cả các file trong toàn bộ project (bao gồm cả module con)
        def filesToDelete = fileTree(dir: rootDir).matching {
            include "**/${targetName}"
            // Loại trừ thư mục build để tránh quét nhầm file đã biên dịch
            exclude "**/build/**"
            exclude "**/.gradle/**"
        }

        filesToDelete.each { File file ->
            println "Đang xóa: ${file.absolutePath}"
            delete file
        }
    }
}


task mergeYamlConfigs {
    group = "custom"
    description = "Gộp file application.yml từ module a:b:c vào module d:e"

    doLast {
        // 1. Xác định đường dẫn file (Thay đổi cho đúng cấu trúc folder của bạn)
        def fileABC = file("${rootDir}/spring/library/web/application.yml")
        def fileDE = file("${rootDir}/spring/integration/broker/kafka/service/producer/bank/src/main/resources/application.yml")
        def fileOutput = file("${rootDir}/spring/integration/broker/kafka/service/producer/bank/src/main/resources/application-merged.yml")

        if (!fileABC.exists()) throw new GradleException("Không tìm thấy file tại module abc")
        if (!fileOutput.exists()) fileOutput.createNewFile()

        Yaml yaml = new Yaml()

        // 2. Load Multi-document YAML (Xử lý các phần ngăn cách bởi ---)
        def docsABC = yaml.loadAll(fileABC.text).collect { it }
        def docsDE = fileDE.exists() ? yaml.loadAll(fileDE.text).collect { it } : [[:]]

        // 3. Logic Merge
        // Chúng ta sẽ lấy docsDE làm gốc, sau đó duyệt docsABC để bổ sung/ghi đè
        def mergedDocs = mergeYamlLists(docsDE, docsABC)

        // 4. Ghi ra file mới với định dạng chuẩn YAML
        DumperOptions options = new DumperOptions()
        options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK)
        options.setPrettyFlow(true)
        Yaml writer = new Yaml(options)

        fileOutput.withWriter('UTF-8') { out ->
            mergedDocs.eachWithIndex { doc, index ->
                if (doc != null && !doc.isEmpty()) {
                    writer.dump(doc, out)
                    if (index < mergedDocs.size() - 1) {
                        out.write("---\n")
                    }
                }
            }
        }
        println "Hoàn thành! File đã được gộp tại: ${fileOutput.absolutePath}"
    }
}

// Hàm hỗ trợ đệ quy để merge Map
def mergeMaps(Map base, Map override) {
    override.each { key, value ->
        if (base.containsKey(key)) {
            if (value instanceof Map && base[key] instanceof Map) {
                mergeMaps(base[key], value)
            } else if (base[key] != value) {
                // Nếu value khác nhau -> Ghi đè
                base[key] = value
            }
            // Nếu value giống hệt nhau -> Tự động bỏ qua (không làm gì)
        } else {
            // Key mới -> Thêm vào
            base[key] = value
        }
    }
    return base
}

// Hàm xử lý danh sách các Document (cho multi-profile)
def mergeYamlLists(List baseDocs, List overrideDocs) {
    // Để đơn giản, ta map các document theo profile name
    def findProfile = { doc ->
        return doc?.spring?.config?.activate?.get("on-profile") ?: "default"
    }

    def resultDocs = []
    def processedProfiles = []

    // Duyệt qua các doc hiện có ở module DE
    baseDocs.each { bDoc ->
        def profile = findProfile(bDoc)
        def oDoc = overrideDocs.find { findProfile(it) == profile }
        if (oDoc) {
            mergeMaps(bDoc, oDoc)
            processedProfiles << profile
        }
        resultDocs << bDoc
    }

    // Thêm các doc chỉ có ở module ABC mà DE chưa có
    overrideDocs.each { oDoc ->
        def profile = findProfile(oDoc)
        if (!processedProfiles.contains(profile)) {
            resultDocs << oDoc
        }
    }

    return resultDocs
}

task mergeMultipleYamlConfigs {
    group = "custom"
    doLast {
        // 1. Khai báo danh sách các file nguồn cần gộp vào
        def sourceFiles = [
                file("${rootDir}/spring/library/web/application.yml")
        ]

        // 2. File đích (module d:e)
        def targetFile = file("${rootDir}/spring/integration/broker/kafka/service/producer/bank/src/main/resources/application.yml")
        def outputFile = file("${rootDir}/spring/integration/broker/kafka/service/producer/bank/src/main/resources/application-merged.yml")

        Yaml yaml = new Yaml()
        def finalDocsMap = [:] // Key: profile name, Value: Map content

        // Hàm helper lấy profile an toàn (đã fix lỗi on-profile)
        def getProfileName = { doc ->
            if (doc == null) return "default"
            try {
                return doc.get("spring")?.get("config")?.get("activate")?.get("on-profile") ?: "default"
            } catch (Exception e) { return "default" }
        }

        // Hàm merge Map đệ quy
        def mergeMaps
        mergeMaps = { Map base, Map override ->
            override.each { key, value ->
                if (base.containsKey(key)) {
                    if (value instanceof Map && base[key] instanceof Map) {
                        mergeMaps(base[key], value)
                    } else if (base[key] != value) {
                        base[key] = value // Khác value thì đè lại giá trị
                    }
                } else {
                    base[key] = value // Key mới thì thêm vào
                }
            }
        }

        // --- BẮT ĐẦU QUÁ TRÌNH GỘP ---

        // Bước A: Load file gốc (Target) làm nền tảng
        if (targetFile.exists()) {
            yaml.loadAll(targetFile.text).each { doc ->
                if (doc != null) finalDocsMap[getProfileName(doc)] = doc
            }
        }

        // Bước B: Lặp qua từng file nguồn để gộp vào
        sourceFiles.each { sFile ->
            if (sFile.exists()) {
                println "Đang gộp file: ${sFile.path}"
                yaml.loadAll(sFile.text).each { doc ->
                    if (doc != null) {
                        def pName = getProfileName(doc)
                        if (finalDocsMap.containsKey(pName)) {
                            mergeMaps(finalDocsMap[pName], doc)
                        } else {
                            finalDocsMap[pName] = doc
                        }
                    }
                }
            } else {
                println "Cảnh báo: Không tìm thấy file ${sFile.path}"
            }
        }

        // 3. Xuất kết quả
        DumperOptions options = new DumperOptions()
        options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK)
        options.setPrettyFlow(true)
        Yaml writer = new Yaml(options)

        outputFile.withWriter('UTF-8') { out ->
            finalDocsMap.values().eachWithIndex { doc, index ->
                writer.dump(doc, out)
                if (index < finalDocsMap.size() - 1) {
                    out.write("---\n")
                }
            }
        }

        println "------------------------------------------"
        println "Hoàn thành! Đã gộp ${sourceFiles.size()} file vào ${outputFile.name}"
    }
}
